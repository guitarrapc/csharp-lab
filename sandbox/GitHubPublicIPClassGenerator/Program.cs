using ConsoleAppFramework;
using System.Net;
using System.Net.Http.Json;
using System.Reflection;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

await ConsoleApp.RunAsync(args, GitHubIPFetcher.GenerateCsharpClass);

#pragma warning disable CA1050 // Declare types in namespaces
public class GitHubMetaApi
{
    public required string[] Actions { get; set; }
}

public class GitHubIPFetcher
{
    // Make 1 line JSON & Match EKS JSON camel case
    private static readonly JsonSerializerOptions jsonOptions = new()
    {
        DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull,
        PropertyNamingPolicy = JsonNamingPolicy.SnakeCaseLower,
        WriteIndented = false,
    };

    public static async Task<int> GenerateCsharpClass(string path, string ns, string className, bool isStatic, bool isPartial, bool dryrun)
    {
        WriteLog("Showing input Parameters...");
        WriteLog($"========================================");
        WriteLog($"* Current Directory: {Directory.GetCurrentDirectory()}");
        WriteLog($"* Path: {path}");
        WriteLog($"* Namespace: {ns}");
        WriteLog($"* ClassName: {className}");
        WriteLog($"* isStatic: {isStatic}");
        WriteLog($"* isPartial: {isPartial}");
        WriteLog($"* Dryrun: {dryrun}");
        WriteLog($"========================================");

        WriteLog("Validate output path's directory is valid.");
        var directoryName = Path.GetDirectoryName(Path.GetFullPath(path));
        if (!Directory.Exists(directoryName))
            throw new DirectoryNotFoundException(directoryName);

        WriteLog("Obtaining GitHub Public IP List from metadata API...");
        var addresses = await GetGitHubActionsIpListAsync();
        var merged = Logic.Core.Networks.CidrAggregatorv4.Aggregate(addresses);

        WriteLog($"Creating C# Class file contents with GitHub Public IPs ({merged.Count} items)...");
        var contents = GenerateAddressClassContents(ns, className, isStatic, isPartial, merged);
        var contentBytes = Encoding.UTF8.GetBytes(contents);

        WriteLog($"C# Class file status...");
        var exists = File.Exists(path);
        var currentSize = exists ? File.ReadAllBytes(path).Length : 0;
        var newSize = contentBytes.Length;
        WriteLog($"* File Exists: {exists}");
        WriteLog($"* File Size Change: {currentSize} -> {newSize} bytes");

        if (dryrun)
        {
            WriteLog("(Dryrun) Showing contents, dry-run mode never create class file...");
            Console.WriteLine("```");
            Console.WriteLine(contents);
            Console.WriteLine("```");
        }
        else
        {
            WriteLog($"Writing to a file {path}...");
            var dir = Path.GetDirectoryName(path)!;
            if (!Directory.Exists(dir))
            {
                Directory.CreateDirectory(dir);
            }

            File.WriteAllBytes(path, contentBytes);
        }

        WriteLog($"All operation complete, please see {path} for the result...");
        return 0;
    }

    /// <summary>
    /// Create C# Class file which contains GitHub's Public IP List.
    /// </summary>
    private static string GenerateAddressClassContents(string @namespace, string className, bool isStatic, bool isPartial, IReadOnlyList<string> addresses)
    {
        var staticKeyword = isStatic ? " static" : "";
        var partialKeyword = isPartial ? " partial" : "";
        var quoatedAddresses = addresses.Select(x => $"\"{x}\"").ToArray();

        var contents = $$"""
        //------------------------------------------------------------------------------
        // <auto-generated>
        // This code was generated by a tool {{Assembly.GetEntryAssembly()!.GetName().Name}}
        //
        // DO NOT MODIFY THIS FILE, CHANGES WILL BE OVERWRITTEN BY CI.
        //
        // Changes to this file may cause incorrect behavior and will be lost if
        // the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------
        namespace {{@namespace}};

        public{{staticKeyword}}{{partialKeyword}} class {{className}}
        {
            /// <summary>
            /// GitHub Public IPv4 List. Updated by <see href="https://github.com/guitarrapc/csharp-lab/actions/workflows/update-github-ip.yaml">GitHub Actions</see>
            /// </summary>
            public static readonly IReadOnlyList<string> GitHubIPList = [
                {{string.Join(",\n        ", quoatedAddresses)}}
            ];
        }
        """.Replace("\r\n", "\n");

        return contents;
    }

    /// <summary>
    /// GitHubのmeta APIからGitHub Actionsの許可IP(CIDR形式)を取得します。
    /// </summary>
    /// <returns></returns>
    private static async Task<string[]> GetGitHubActionsIpListAsync()
    {
        // GitHubのIPアドレス許可を拾ってくる。IPv4入れると4509、IPv6だけなら3711。
        // NSGのソースIPは上限4000なのでIPv6を除いてみる。1つのルールに8IPまで入るがソースIPの数はごまかせないのです。これでダメならFirewall使うかIP制限なしになりそう。
        using var client = new HttpClient();
        client.DefaultRequestHeaders.Add("User-Agent", "linqpad"); // ないと403で怒られる
        SetAuthorizationHeader(client, "GH_TOKEN"); // トークンがないとAPIレートリミットに引っかかりやすいので、トークンが獲れるなら使う
        var githubApiResult = await client.GetFromJsonAsync<GitHubMetaApi>("https://api.github.com/meta", jsonOptions);
        var githubIPs = githubApiResult!.Actions
            .Where(x => IPAddress.TryParse(x.Split('/')[0], out var y) && y.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
            .OrderBy(x => x)
            .ToArray();
        return githubIPs ?? [];

        void SetAuthorizationHeader(HttpClient client, string EnvironmentKey)
        {
            var token = Environment.GetEnvironmentVariable(EnvironmentKey);
            if (string.IsNullOrEmpty(token))
            {
                WriteLog($"Environment Variable {EnvironmentKey} not found, use anonymous request to GitHub Meta API. Consider use token to avoid rate limit.");
                return;
            }

            WriteLog($"Environment Variable {EnvironmentKey} found, use token to request GitHub Meta API.");
            client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);
        }
    }

    private static void WriteLog(string value)
    {
        Console.WriteLine($"[{DateTime.Now:s}] {value}");
    }
}
